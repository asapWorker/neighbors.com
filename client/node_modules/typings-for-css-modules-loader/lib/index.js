'use strict';

var _cssLoader = require('css-loader');

var _cssLoader2 = _interopRequireDefault(_cssLoader);

var _locals = require('css-loader/locals');

var _locals2 = _interopRequireDefault(_locals);

var _cssModuleToInterface = require('./cssModuleToInterface');

var _persist = require('./persist');

var persist = _interopRequireWildcard(_persist);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (input) {
  var _this = this;

  if (this.cacheable) this.cacheable();

  // mock async step 1 - css loader is async, we need to intercept this so we get async ourselves
  var callback = this.async();
  // mock async step 2 - offer css loader a "fake" callback
  this.async = function () {
    return function (err, content) {
      var cssmodules = _this.exec(content, _this.resource);
      var requestedResource = _this.resourcePath;

      var cssModuleInterfaceFilename = (0, _cssModuleToInterface.filenameToTypingsFilename)(requestedResource);
      var cssModuleInterface = (0, _cssModuleToInterface.generateInterface)(cssmodules, requestedResource);
      persist.writeToFileIfChanged(cssModuleInterfaceFilename, cssModuleInterface);
      // mock async step 3 - make `async` return the actual callback again before calling the 'real' css-loader
      _this.async = function () {
        return callback;
      };
      _cssLoader2.default.call(_this, input);
    };
  };
  _locals2.default.call(this, input);
};